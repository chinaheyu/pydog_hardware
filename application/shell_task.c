#include "shell_task.h"
#include "cmsis_os.h"
#include "FreeRTOS_CLI.h"
#include "shell_commands.h"
#include "fatfs.h"
#include "bsp_usart.h"


#define CMD_BUFSIZE 64
#define cmdMAX_INPUT_SIZE CMD_BUFSIZE

/* DEL acts as a backspace. */
#define cmdASCII_DEL		( 0x7F )

// FIFO Buffer
fifo_s_t shell_fifo;
char shell_buf[CMD_BUFSIZE];

// 输出缓冲区
char* cOutputBuffer;

// Tx Mutex
extern osMutexId_t cliTxMutexHandle;

static const char * const pcWelcomeMessage = " _______     _______   ____   _____\r\n \
|  __ \\ \\   / /  __ \\ / __ \\ / ____|\r\n \
| |__) \\ \\_/ /| |  | | |  | | |  __ \r\n \
|  ___/ \\   / | |  | | |  | | | |_ |\r\n \
| |      | |  | |__| | |__| | |__| |\r\n \
|_|      |_|  |_____/ \\____/ \\_____|\r\n \
\r\nWelcome to pydog hardware command server.\r\nType 'help' to view a list of registered commands.\r\n";
static const char * const pcEndOfOutputMessage = "pydog>> ";
static const char * const pcNewLine = "\r\n";

signed char cRxedChar;
uint8_t ucInputIndex = 0;
char *pcOutputString;
static char cInputString[ cmdMAX_INPUT_SIZE ], cLastInputString[ cmdMAX_INPUT_SIZE ];
BaseType_t xReturned;

uint32_t usart1_rx_callback(uint8_t *buff, uint16_t len)
{
    fifo_s_puts_noprotect(&shell_fifo, (char *)buff, len);
    return 0;
}

extern void vRegisterSampleCLICommands( void );
extern void vRegisterFileSystemCLICommands( void );

void cli_send(const char *out_str);

void cli_cmd_init(void)
{
    // 如果有SD卡，挂载并加载相关命令
    retSD = f_mount(&SDFatFS, SDPath, 1);
    if(retSD == FR_OK)
    {
        vRegisterFileSystemCLICommands();
        cli_send("Detected external storage device, automatic mounting successful.\r\n");
    }
    
    vRegisterSampleCLICommands();
    register_shell_commands();
}

/* 终端命令解析处理 */
void cli_process(char *str_buf, int str_len)
{
    int str_idx = 0;

    while (str_idx < str_len)
    {
        cRxedChar = str_buf[str_idx];
        str_idx ++;
        
        /* Ensure exclusive access to the UART Tx. */
		if(osMutexAcquire(cliTxMutexHandle, 0U) == osOK)
		{
			/* Was it the end of the line? */
			if( cRxedChar == '\n' || cRxedChar == '\r' )
			{
                if(ucInputIndex > 0)
                {
                    /* Just to space the output from the input. */
                    usart1_transmit((uint8_t*)pcNewLine, strlen(pcNewLine));
                    
                    /* Pass the received command to the command interpreter.  The
                    command interpreter is called repeatedly until it returns
                    pdFALSE	(indicating there is no more output) as it might
                    generate more than one string. */
                    do
                    {
                        /* Get the next output string from the command interpreter. */
                        xReturned = FreeRTOS_CLIProcessCommand( cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE );

                        /* Write the generated string to the UART. */
                        usart1_transmit((uint8_t*)pcOutputString, strlen(pcOutputString));

                    } while( xReturned != pdFALSE );
                    
                    usart1_transmit((uint8_t*)pcEndOfOutputMessage, strlen( pcEndOfOutputMessage));
                }

				/* All the strings generated by the input command have been
				sent.  Clear the input string ready to receive the next command.
				Remember the command that was just processed first in case it is
				to be processed again. */
				strcpy( cLastInputString, cInputString );
				ucInputIndex = 0;
				memset( cInputString, 0x00, cmdMAX_INPUT_SIZE );
			}
			else
			{
				if( ( cRxedChar == '\b' ) || ( cRxedChar == cmdASCII_DEL ) )
				{
					/* Backspace was pressed.  Erase the last character in the
					string - if any. */
					if( ucInputIndex > 0 )
					{
						ucInputIndex--;
						cInputString[ ucInputIndex ] = '\0';
                        
                        /* Echo the character back. */
                        usart1_transmit((uint8_t*)"\b", 1);
					}
				}
				else
				{
					/* A character was entered.  Add it to the string entered so
					far.  When a \n is entered the complete	string will be
					passed to the command interpreter. */
					if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
					{
						if( ucInputIndex < cmdMAX_INPUT_SIZE )
						{
							cInputString[ ucInputIndex ] = cRxedChar;
							ucInputIndex++;
                            
                            /* Echo the character back. */
                            usart1_transmit((uint8_t*)&cRxedChar, sizeof(cRxedChar));
						}
					}
				}
			}

			/* Must ensure to give the mutex back. */
			osMutexRelease(cliTxMutexHandle);
        }
    }
}

void cli_send(const char *out_str)
{
    if(osMutexAcquire(cliTxMutexHandle, osWaitForever) == osOK)
    {
        usart1_transmit((uint8_t *)out_str, strlen(out_str) + 1);
        osMutexRelease(cliTxMutexHandle);
    }
}

void shell_task(void *argument)
{
    (void)argument;
    
    // 分配输出缓冲内存
    cOutputBuffer = pvPortMalloc(configCOMMAND_INT_MAX_OUTPUT_SIZE);
    
    // 初始化fifo
    fifo_s_init(&shell_fifo, shell_buf, CMD_BUFSIZE);
    
    // 注册回调函数
    usart1_rx_callback_register(usart1_rx_callback);
    
    char input_buf[CMD_BUFSIZE];
    int ret;
    
    pcOutputString = FreeRTOS_CLIGetOutputBuffer();
    
    sprintf(pcOutputString, "pydog_hardware: https://github.com/chinaheyu/pydog_hardware\r\nbuild time: %s-%s\r\n\r\n%s\r\n", __DATE__, __TIME__, pcWelcomeMessage);
    cli_send(pcOutputString);

    cli_cmd_init();

    cli_send(pcEndOfOutputMessage);
    
    while (1)
    {
        uint16_t used_len;
        used_len = shell_fifo.used_num;
        ret = fifo_s_gets(&shell_fifo, input_buf, used_len);
        if (ret > 0)
        {
            cli_process(input_buf, ret);
        }
        osDelay(50);
    }
}

